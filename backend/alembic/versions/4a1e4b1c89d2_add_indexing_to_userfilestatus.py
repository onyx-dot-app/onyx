"""Add INDEXING to UserFileStatus

Revision ID: 4a1e4b1c89d2
Revises: 6b3b4083c5aa
Create Date: 2026-02-28 00:00:00.000000

"""

import sqlalchemy as sa
from alembic import op

revision = "4a1e4b1c89d2"
down_revision = "6b3b4083c5aa"
branch_labels = None
depends_on = None

TABLE = "user_file"
COLUMN = "status"
CONSTRAINT_NAME = "ck_user_file_status"

OLD_VALUES = ("PROCESSING", "COMPLETED", "FAILED", "CANCELED", "DELETING")
NEW_VALUES = ("PROCESSING", "INDEXING", "COMPLETED", "FAILED", "CANCELED", "DELETING")


def _drop_status_check_constraint() -> None:
    """Drop the existing CHECK constraint on user_file.status.

    The constraint name is auto-generated by SQLAlchemy and unknown,
    so we look it up via the inspector.
    """
    inspector = sa.inspect(op.get_bind())
    for constraint in inspector.get_check_constraints(TABLE):
        if COLUMN in constraint.get("sqltext", ""):
            constraint_name = constraint["name"]
            if constraint_name is not None:
                op.drop_constraint(constraint_name, TABLE, type_="check")


def upgrade() -> None:
    _drop_status_check_constraint()
    in_clause = ", ".join(f"'{v}'" for v in NEW_VALUES)
    op.create_check_constraint(CONSTRAINT_NAME, TABLE, f"{COLUMN} IN ({in_clause})")


def downgrade() -> None:
    op.execute(
        f"UPDATE {TABLE} SET {COLUMN} = 'PROCESSING' WHERE {COLUMN} = 'INDEXING'"
    )
    op.drop_constraint(CONSTRAINT_NAME, TABLE, type_="check")
    in_clause = ", ".join(f"'{v}'" for v in OLD_VALUES)
    op.create_check_constraint(CONSTRAINT_NAME, TABLE, f"{COLUMN} IN ({in_clause})")
