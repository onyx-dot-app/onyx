"""
Transform OpenAPI schema for documentation site.

This script takes the OpenAPI JSON generated by onyx_openapi_schema.py and:
1. Filters to only include endpoints tagged with "public"
2. Keeps only the schemas referenced by those endpoints
3. Changes authorization to Bearer token
4. Sets server URL to https://cloud.onyx.app/api
5. Removes internal parameters (tenant_id, db_session)

Usage:
    # Generate the docs OpenAPI spec
    python scripts/transform_openapi_for_docs.py -i generated/openapi.json -o openapi_docs.json

    # List all public endpoints in the source spec
    python scripts/transform_openapi_for_docs.py -i generated/openapi.json --list-endpoints
"""

import argparse
import copy
import json
from typing import Any


# Tag that marks endpoints for public API documentation
# This should match PUBLIC_API_TAGS in onyx/server/utils.py
PUBLIC_TAG = "public"

# Server URL for documentation
DOCS_SERVER_URL = "https://cloud.onyx.app/api"

# Parameters to remove from endpoints (internal use only)
INTERNAL_PARAMETERS = {"tenant_id", "db_session"}


def collect_schema_refs(obj: Any, refs: set[str]) -> None:
    """Recursively collect all $ref references from an object."""
    if isinstance(obj, dict):
        if "$ref" in obj:
            ref = obj["$ref"]
            # Extract schema name from "#/components/schemas/SchemaName"
            if ref.startswith("#/components/schemas/"):
                refs.add(ref.split("/")[-1])
        for value in obj.values():
            collect_schema_refs(value, refs)
    elif isinstance(obj, list):
        for item in obj:
            collect_schema_refs(item, refs)


def get_all_referenced_schemas(
    schemas: dict[str, Any], initial_refs: set[str]
) -> set[str]:
    """Get all schemas referenced by initial_refs, including nested references."""
    all_refs = set(initial_refs)
    to_process = list(initial_refs)

    while to_process:
        schema_name = to_process.pop()
        if schema_name not in schemas:
            continue

        schema = schemas[schema_name]
        new_refs: set[str] = set()
        collect_schema_refs(schema, new_refs)

        for ref in new_refs:
            if ref not in all_refs:
                all_refs.add(ref)
                to_process.append(ref)

    return all_refs


def is_public_endpoint(method_data: dict[str, Any]) -> bool:
    """Check if an endpoint is tagged as public."""
    tags = method_data.get("tags", [])
    return PUBLIC_TAG in tags


def transform_security_scheme(spec: dict[str, Any]) -> None:
    """Replace cookie-based auth with Bearer token auth."""
    if "components" not in spec:
        spec["components"] = {}

    spec["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "description": "Authorization header with Bearer token",
        }
    }

    # Update security requirements in all paths
    for path_data in spec.get("paths", {}).values():
        for method_data in path_data.values():
            if isinstance(method_data, dict) and "security" in method_data:
                method_data["security"] = [{"BearerAuth": []}]


def remove_internal_properties_from_schema(schema: dict[str, Any]) -> None:
    """Recursively remove internal properties from a schema."""
    if not isinstance(schema, dict):
        return

    # Remove internal properties
    if "properties" in schema and isinstance(schema["properties"], dict):
        for prop_name in list(schema["properties"].keys()):
            if prop_name in INTERNAL_PARAMETERS:
                del schema["properties"][prop_name]

        # Also remove from required list if present
        if "required" in schema and isinstance(schema["required"], list):
            schema["required"] = [
                r for r in schema["required"] if r not in INTERNAL_PARAMETERS
            ]
            if not schema["required"]:
                del schema["required"]

    # Recurse into nested schemas
    for key in ["allOf", "oneOf", "anyOf"]:
        if key in schema and isinstance(schema[key], list):
            for item in schema[key]:
                remove_internal_properties_from_schema(item)

    if "items" in schema:
        remove_internal_properties_from_schema(schema["items"])

    if "additionalProperties" in schema and isinstance(
        schema["additionalProperties"], dict
    ):
        remove_internal_properties_from_schema(schema["additionalProperties"])


def remove_internal_parameters(spec: dict[str, Any]) -> None:
    """Remove internal parameters from all endpoints and schemas."""
    # Remove from path/query parameters
    for path_data in spec.get("paths", {}).values():
        for method_data in path_data.values():
            if isinstance(method_data, dict) and "parameters" in method_data:
                method_data["parameters"] = [
                    p
                    for p in method_data["parameters"]
                    if not (
                        isinstance(p, dict) and p.get("name") in INTERNAL_PARAMETERS
                    )
                ]
                # Remove empty parameters list
                if not method_data["parameters"]:
                    del method_data["parameters"]

    # Remove from schemas
    for schema in spec.get("components", {}).get("schemas", {}).values():
        remove_internal_properties_from_schema(schema)


def transform_openapi(input_spec: dict[str, Any]) -> dict[str, Any]:
    """Transform the OpenAPI spec for documentation."""
    output_spec: dict[str, Any] = {
        "openapi": input_spec.get("openapi", "3.0.3"),
        "info": {
            "title": "Onyx API",
            "description": "Onyx API for AI-powered chat with search, document indexing, agents, and more",
            "version": input_spec.get("info", {}).get("version", "1.0.0"),
        },
        "servers": [{"url": DOCS_SERVER_URL}],
        "paths": {},
        "components": {"schemas": {}, "securitySchemes": {}},
    }

    # Filter paths to only include endpoints tagged as "public"
    input_paths = input_spec.get("paths", {})
    initial_refs: set[str] = set()

    for path, path_data in input_paths.items():
        for method, method_data in path_data.items():
            if not isinstance(method_data, dict):
                continue

            # Only include endpoints tagged as public
            if is_public_endpoint(method_data):
                if path not in output_spec["paths"]:
                    output_spec["paths"][path] = {}

                # Deep copy to avoid modifying the input
                output_spec["paths"][path][method] = copy.deepcopy(method_data)
                collect_schema_refs(method_data, initial_refs)

    # Get all referenced schemas (including nested references)
    input_schemas = input_spec.get("components", {}).get("schemas", {})
    all_refs = get_all_referenced_schemas(input_schemas, initial_refs)

    # Copy only referenced schemas (deep copy to avoid modifying input)
    for schema_name in all_refs:
        if schema_name in input_schemas:
            output_spec["components"]["schemas"][schema_name] = copy.deepcopy(
                input_schemas[schema_name]
            )

    # Transform security scheme
    transform_security_scheme(output_spec)

    # Remove internal parameters (tenant_id, db_session, etc.)
    remove_internal_parameters(output_spec)

    return output_spec


def list_endpoints(spec: dict[str, Any], public_only: bool = True) -> None:
    """Print endpoints in the spec, grouped by prefix."""
    paths = spec.get("paths", {})

    # Group by first path segment
    groups: dict[str, list[tuple[str, str, str, bool]]] = {}
    for path, methods in sorted(paths.items()):
        prefix = path.split("/")[1] if "/" in path else "root"
        if prefix not in groups:
            groups[prefix] = []
        for method, details in methods.items():
            if isinstance(details, dict):
                summary = details.get("summary", "No summary")
                is_public = is_public_endpoint(details)
                if not public_only or is_public:
                    groups[prefix].append((method.upper(), path, summary, is_public))

    # Print grouped
    for prefix in sorted(groups.keys()):
        if not groups[prefix]:
            continue
        print(f"\n=== /{prefix} ===")
        for method, path, summary, is_public in groups[prefix]:
            tag_indicator = "[public] " if is_public else ""
            print(f"  {method:6} {path}")
            print(f"         {tag_indicator}{summary}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Transform OpenAPI schema for documentation site"
    )
    parser.add_argument(
        "--input",
        "-i",
        default="openapi.json",
        help="Input OpenAPI JSON file",
    )
    parser.add_argument(
        "--output",
        "-o",
        default="openapi_docs.json",
        help="Output OpenAPI JSON file for documentation",
    )
    parser.add_argument(
        "--list-endpoints",
        action="store_true",
        help="List all public endpoints in the input spec and exit",
    )
    parser.add_argument(
        "--list-all",
        action="store_true",
        help="List all endpoints (not just public) when using --list-endpoints",
    )

    args = parser.parse_args()

    # Load input spec
    with open(args.input, "r") as f:
        input_spec = json.load(f)

    # If listing endpoints, do that and exit
    if args.list_endpoints:
        if args.list_all:
            print("All endpoints in input spec:")
        else:
            print("Public endpoints in input spec (tagged with 'public'):")
        list_endpoints(input_spec, public_only=not args.list_all)
        return

    # Transform
    output_spec = transform_openapi(input_spec)

    # Write output
    with open(args.output, "w") as f:
        json.dump(output_spec, f, indent=2)

    # Print summary
    endpoint_count = sum(len(methods) for methods in output_spec["paths"].values())
    schema_count = len(output_spec["components"]["schemas"])
    print("Transformed OpenAPI schema for documentation:")
    print(f"  - {len(output_spec['paths'])} paths with {endpoint_count} endpoints")
    print(f"  - {schema_count} schemas")
    print(f"  - Server URL: {DOCS_SERVER_URL}")
    print("  - Auth: Bearer token")
    print(f"  - Filtered by tag: '{PUBLIC_TAG}'")
    print(f"Wrote to {args.output}")


if __name__ == "__main__":
    main()
