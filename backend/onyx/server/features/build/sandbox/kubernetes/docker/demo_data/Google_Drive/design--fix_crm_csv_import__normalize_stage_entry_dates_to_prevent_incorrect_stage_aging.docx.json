{
  "id": "dd3b772b2d7b4e2486c0c3d69ff80639",
  "semantic_identifier": "Design--Fix CRM/CSV import: normalize stage entry dates to prevent incorrect stage aging.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-05-27",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Fix CRM/CSV import: normalize stage entry dates to prevent incorrect stage aging.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "## Overview / Problem\nSales Forecast \u201cstage aging\u201d is incorrect for opportunities imported via CRM/CSV because `stage_entered_at` values are inconsistently parsed (varied formats, missing timezone) and in some cases default to `created_at`. This causes downstream rollups and conversion benchmarks to compute inflated or deflated time-in-stage. We need to normalize all imported stage transition timestamps into a canonical representation so stage aging is deterministic and comparable across sources.\n\n## Proposed Change\nUpdate the import pipeline to derive and persist a canonical `stage_entered_at` for each stage transition. During import, we will parse all candidate timestamps using a strict normalization step: accept known input formats, require/derive timezone (prefer explicit timezone; otherwise use configured account/import timezone; finally fall back to UTC), and store in UTC. For each opportunity, we will build an ordered list of stage transitions and set `stage_entered_at` per stage based on the best available source field (e.g., CRM stage history timestamp, CSV \u201cstage changed at\u201d), ensuring monotonicity (no transition earlier than the previous). If no stage-transition timestamp exists, we fall back deterministically (e.g., opportunity `created_at` for initial stage only; otherwise previous stage\u2019s `stage_entered_at` or import timestamp per documented rule).\n\n## Data / Backfill\nIntroduce (or standardize) a single canonical field used by aging calculations (e.g., `opportunity_stage_transitions.stage_entered_at_utc`) and ensure the aggregator reads only this canonical value. Add instrumentation on import to surface parsing failures and fallback usage rates. Provide a targeted backfill for imported opportunities where stage aging is currently computed from non-normalized dates: re-run normalization for affected records, rebuild stage transition rows, and invalidate/recompute rollups that depend on stage aging.\n\n## Acceptance Criteria / Testing\nImported opportunities (CRM and CSV) must produce stable stage aging values regardless of input timestamp format or missing timezone, with `stage_entered_at` stored in UTC and stage transitions strictly ordered. Unit tests should cover representative timestamp formats, timezone-less inputs, and fallback paths; integration tests should validate end-to-end stage aging before/after import against expected durations. Monitoring should alert on elevated fallback rates or parse errors to prevent regressions as new CRM/CSV formats appear.",
      "link": "https://www.onyx.app/90712"
    }
  ],
  "primary_owners": [
    "jason_morris"
  ],
  "secondary_owners": []
}