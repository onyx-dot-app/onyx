{
  "id": "35e5354c46dd47ad838c03b2c9377421",
  "semantic_identifier": "Design--Integrations: Add mapping validation to prevent field mismatches and duplicate mappings.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-06-27",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Integrations: Add mapping validation to prevent field mismatches and duplicate mappings.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Overview & Goals  \nWe will add pre-save validation to the integrations field-mapping UI and backend API to prevent invalid mappings from being persisted. The validator will detect (1) data type mismatches between source and destination fields, (2) missing required source fields needed to populate required destination fields, and (3) duplicate/conflicting mappings where multiple source fields map to the same destination field and/or a single source field maps to multiple destinations (when the integration contract expects 1:1). The primary goal is to block saving invalid configurations and replace downstream failures/duplicate signals with immediate, actionable feedback.\n\n### Validation Rules & Data Model Assumptions  \nValidation runs against a normalized \u201cmapping\u201d object: `{ sourceFieldId, destinationFieldId, transform? }`, plus field metadata retrieved from the integration schema (type, required, allowedTransforms, cardinality). Rules: (a) **Type compatibility**: source type must be assignable to destination type after any declared transform (e.g., string\u2192int only if a supported cast transform is selected). (b) **Required coverage**: each required destination field must have exactly one valid source mapping (or an explicitly supported default/static value). (c) **Uniqueness/cardinality**: enforce destination uniqueness (no two sources to one destination) and source uniqueness where applicable (no one source to multiple destinations) based on integration capabilities. These rules will be implemented server-side as the source of truth; UI will mirror them for fast feedback.\n\n### UX/API Behavior & Error Reporting  \nOn \u201cSave mapping,\u201d the UI calls a validation endpoint (or the save endpoint performs validation and returns 4xx). If validation fails, saving is blocked and the response includes structured errors with field identifiers and a human-readable message. Example error payload: `{ code: \"DUPLICATE_DESTINATION\", destinationFieldId, sourceFieldIds: [...], message }`, `{ code: \"TYPE_MISMATCH\", sourceFieldId, destinationFieldId, expectedType, actualType }`, `{ code: \"MISSING_REQUIRED_DESTINATION\", destinationFieldId }`. The UI highlights the offending rows, groups errors by destination field, and provides inline guidance (e.g., \u201cChoose a different destination\u201d / \u201cAdd a transform\u201d / \u201cMap a source field to required destination X\u201d).\n\n### Implementation Plan & Rollout  \nBackend: add a `validateMappings(mappings, sourceSchema, destinationSchema)` function used by both `POST/PUT /integrations/{id}/mappings` (save) and an optional `POST /integrations/{id}/mappings/validate` (preview) endpoint; return `422 Unprocessable Entity` with structured errors. Frontend: run lightweight client-side checks (duplicate destination/source) for immediate feedback, but rely on server validation for schema/type/required checks and final gating. Rollout behind a feature flag per integration type; add metrics for validation failure counts by code, and logging that includes integration id and field ids (no PII). Add unit tests for validator rules and a small set of integration tests to ensure invalid mappings cannot be persisted.",
      "link": "https://www.onyx.app/18558"
    }
  ],
  "primary_owners": [
    "jason_morris"
  ],
  "secondary_owners": []
}