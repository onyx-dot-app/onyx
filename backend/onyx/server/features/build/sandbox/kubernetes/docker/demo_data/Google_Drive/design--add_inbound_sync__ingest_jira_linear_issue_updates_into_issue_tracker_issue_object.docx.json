{
  "id": "9d9207d5cb3f4811bbef4ce1606cfc5e",
  "semantic_identifier": "Design--Add inbound sync: ingest Jira/Linear issue updates into Issue_Tracker issue object.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-05-05",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add inbound sync: ingest Jira/Linear issue updates into Issue_Tracker issue object.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "This feature adds the inbound (downstream) sync path that ingests updates from Jira/Linear and applies them to the corresponding linked `Issue_Tracker` issue object. The goal is to keep `Issue_Tracker` aligned when changes happen externally (status/state, priority, title, labels, assignee), while preserving `Issue_Tracker`-specific fields and context. This complements the existing outbound sync by ensuring linked issues converge over time.\n\nWe will implement polling as the initial ingestion mechanism. A scheduled worker will iterate over active links, fetch external issues updated since the last successful sync (incremental), and enqueue per-issue update jobs. Each job retrieves the latest external issue, computes a field-level diff, and applies updates to `Issue_Tracker` only for fields that are explicitly mapped/configured for that integration/link (e.g., if labels aren\u2019t mapped, do not touch labels). This prevents accidental overwrites and supports partial rollouts per workspace/project.\n\nTo support incremental fetches and idempotency, we will persist `last_synced_at` on the link (or per integration scope) along with the external system\u2019s `updated_at` (and any available external revision/etag) for each linked issue. During processing we will skip applying updates if the external `updated_at` is not newer than what we last observed, and we will make writes idempotent by setting fields to the computed target state rather than applying \u201cdeltas.\u201d We will also record per-run metrics (fetched, updated, skipped, failed) and per-link sync timestamps to aid observability and backfills.\n\nError handling will be non-destructive: permission errors, missing external issues, or missing `Issue_Tracker` issues will be logged with structured context and surfaced via alerts, but the link will remain intact (no automatic unlink). We will mark the link as \u201cdegraded\u201d (or store the last error + timestamp) to avoid noisy retries and to enable UI/admin remediation. Webhooks are explicitly out of scope for this ticket but the polling pipeline will be designed so the same \u201cingest external update \u2192 diff \u2192 mapped apply\u201d core can be triggered by a webhook handler later.",
      "link": "https://www.onyx.app/41570"
    }
  ],
  "primary_owners": [
    "brooke_spencer"
  ],
  "secondary_owners": []
}