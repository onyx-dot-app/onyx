{
  "id": "279245a043a647419c08c7a0f87f1b97",
  "semantic_identifier": "Design--Fix Jira/Linear link-out: generate correct deep links and handle missing/mismatched IDs.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-01",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Fix Jira/Linear link-out: generate correct deep links and handle missing/mismatched IDs.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We should make Jira/Linear link-outs from Issue_Tracker reliable by generating deep links from integration configuration (base URL + workspace slug) and by validating the stored external identifiers before we render any outbound link. Today, we appear to concatenate or assume a key/ID shape that can vary by workspace (e.g., Jira key vs numeric ID, Linear issue identifier vs internal UUID), and we don\u2019t defensively handle stale mappings, so users land on 404s or the wrong downstream item.\n\nImplementation: centralize link generation behind an `ExternalLinkBuilder` that takes `(integration_type, integration_config, external_reference)` and returns either a verified URL or an invalid state. For Jira, use the configured site base URL and prefer a stable \u201cbrowse/<issueKey>\u201d deep link when the stored reference is a key; if only an ID is stored, generate the canonical issue URL for that site (or resolve ID\u2192key via API when available, caching the result). For Linear, use the configured workspace slug/base URL and generate the canonical issue URL from the issue identifier; if we store a Linear UUID, resolve it to the human-readable identifier once and persist/update the mapping to avoid repeated lookups.\n\nValidation and UI behavior: before showing a link, validate that the external reference matches expected patterns per integration and (when feasible) confirm existence via a lightweight API call (or rely on a recently verified timestamp to avoid latency on every render). If validation fails or the reference is missing, render a \u201cNot linked\u201d state in Issue_Tracker with a clear explanation and an action: \u201cReconnect\u201d (re-auth/reselect integration) and/or \u201cRetry\u201d (re-validate / re-resolve mapping). Clicking \u201cRetry\u201d should attempt to resolve the mapping (e.g., Jira ID\u2192key, Linear UUID\u2192identifier) and update stored references atomically; failures should be surfaced with a non-blocking error.\n\nRollout: add logging/metrics for invalid references, resolution attempts, and successful remaps, plus a small backfill job that scans existing mappings and pre-resolves known-stale IDs to canonical forms. Gate the new behavior behind a feature flag per workspace to minimize risk, and add unit tests for URL generation across config variants and integration types, along with integration tests that cover missing ID, mismatched format, stale mapping remediation, and the \u201cNot linked\u201d UI state.",
      "link": "https://www.onyx.app/20294"
    }
  ],
  "primary_owners": [
    "andre_robinson"
  ],
  "secondary_owners": []
}