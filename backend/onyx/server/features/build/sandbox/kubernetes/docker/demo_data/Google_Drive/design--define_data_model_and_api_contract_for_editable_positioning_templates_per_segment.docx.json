{
  "id": "6065e2508fd14f35b63a60659da675e9",
  "semantic_identifier": "Design--Define data model + API contract for editable positioning templates per segment.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-04",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Define data model + API contract for editable positioning templates per segment.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We will introduce a new backend entity, **SegmentPositioningTemplate**, scoped to a `segment_id` (and implicitly to its `workspace_id`), to store editable positioning content used by the UI (value props, differentiators, proof points, objections). The data model will include `id`, `workspace_id`, `segment_id` (unique), `content` (JSON), and audit/versioning fields: `version` (monotonic int), `created_at`, `created_by`, `updated_at`, `updated_by`, plus optional `published_version`/`published_at` if we need a \u201clast approved\u201d pointer. `content` will be a structured JSON object with arrays of items per section (each item having `id`, `text`, optional `tags`/`sources`, and `order`). On first access, if a segment has no template, we will create one using sensible defaults (empty sections or workspace-level defaults if available), ensuring the UI always has a complete shape to render.\n\nWe will provide minimal CRUD via two endpoints: `GET /v1/segments/{segmentId}/positioning-template` to fetch the current template (creating defaults if missing), and `PUT /v1/segments/{segmentId}/positioning-template` to replace/update the template content. The response payload will include `templateId`, `segmentId`, `version`, `content`, and audit fields; the PUT request will accept `content` plus an optional `expectedVersion` for optimistic concurrency (reject with 409 on mismatch). We\u2019ll also support `PATCH` later if we need partial updates, but for now a full `PUT` keeps the contract simple and reduces merge complexity on the server.\n\nValidation will enforce the JSON schema: required top-level keys (`valueProps`, `differentiators`, `proofPoints`, `objections`) must exist (empty arrays allowed), each item must have `id` (UUID) and non-empty `text` with max lengths, and section array sizes will be capped (e.g., 50 items/section) to prevent abuse. Authorization will mirror existing workspace access: callers must have read access to the segment\u2019s workspace for GET and write access for PUT; additionally, we\u2019ll verify the `segmentId` belongs to the caller\u2019s workspace to prevent cross-workspace access. All writes will set `updated_by` and increment `version`, with an append-only audit trail optionally stored in a `segment_positioning_template_revisions` table if we need full history beyond the current version.\n\nWe will document the API schema in the repo (OpenAPI + example payloads) for UI consumption. Example response shape: `{ templateId, segmentId, version, content: { valueProps: [{id,text,order}], differentiators: [...], proofPoints: [...], objections: [...] }, createdAt, createdBy, updatedAt, updatedBy }`. This contract enables the next UI tickets to render and edit templates reliably while giving us a clean path to add publishing, partial updates, and richer item metadata later without breaking compatibility.",
      "link": "https://www.onyx.app/12467"
    }
  ],
  "primary_owners": [
    "tyler_jenkins"
  ],
  "secondary_owners": []
}