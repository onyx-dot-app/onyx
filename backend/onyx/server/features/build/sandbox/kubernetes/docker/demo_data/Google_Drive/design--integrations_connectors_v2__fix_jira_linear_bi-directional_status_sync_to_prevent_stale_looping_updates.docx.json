{
  "id": "9cedfcc36a1d4b61ba1988005f1bc9fc",
  "semantic_identifier": "Design--Integrations_connectors v2: Fix Jira/Linear bi-directional status sync to prevent stale/looping updates.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-06-11",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Integrations_connectors v2: Fix Jira/Linear bi-directional status sync to prevent stale/looping updates.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Problem / Goal\nOur current Jira \u2194 Linear bi-directional status sync can produce stale outcomes or \u201cbounce back\u201d loops because we don\u2019t have a clear source-of-truth for the last applied remote state, nor do we treat webhook-driven updates as idempotent. The goal is to make status propagation reliable and loop-free by recording per-issue sync metadata and using it to ignore self-generated updates while still accepting legitimate remote transitions. This should work for Jira \u2194 Linear directly and for flows mediated via `Issue_Tracker`, and it must preserve correct status mapping across systems.\n\n### Proposed Approach\nIntroduce per-issue sync metadata stored with the connector linkage record (or equivalent) for each integrated issue: `last_synced_state` (canonical status value after mapping), `last_synced_at` (timestamp when we successfully applied it), and `origin` (system that produced the change we applied: `jira`, `linear`, `issue_tracker`). When we receive an inbound event (webhook/poll) from system A for issue X, we map its status to the canonical representation and compare against `last_synced_state`. If it matches and the event is within a configurable \u201cecho window\u201d (e.g., a few minutes) and/or can be correlated to our last outbound write, we treat it as a self-echo and no-op. If it differs, we apply the transition to the other side(s), then update `last_synced_*` and set `origin=A` upon successful completion, making the operation idempotent and preventing loops.\n\n### Transition Mapping / Conflict Handling\nStatus transitions must be mapped consistently across Jira workflows and Linear states. We\u2019ll centralize mapping into a single canonical enum (e.g., `todo`, `in_progress`, `done`, `canceled`) with per-integration mapping tables and validation to ensure every configured Jira status maps deterministically. On inbound changes, if the mapped canonical state is unknown/unmappable, we will not apply an outbound change and will record a structured warning + metric. If near-simultaneous updates occur from both sides (detected via timestamps vs `last_synced_at` and differing `origin`), we\u2019ll resolve by \u201clatest wins\u201d using the remote event time when available; otherwise we\u2019ll fall back to receipt time and emit a conflict metric/log including both candidate states for debugging.\n\n### Observability / Rollout\nAdd targeted logs and metrics at the decision points: dropped-as-echo, applied-transition, unmappable-status, conflict-detected, and outbound-failed (with retry outcome). Metrics should be tagged by integration type, project, and state to surface hotspots (e.g., a specific Jira workflow causing unmappable transitions). Roll out behind a feature flag per connector, backfill metadata lazily on first touch (treat missing `last_synced_state` as \u201cunknown\u201d and allow one-time sync), and verify via integration tests that (1) repeated identical webhook events are no-ops, (2) a local write does not bounce back, and (3) legitimate remote changes continue to propagate correctly.",
      "link": "https://www.onyx.app/71306"
    }
  ],
  "primary_owners": [
    "tyler_jenkins"
  ],
  "secondary_owners": []
}