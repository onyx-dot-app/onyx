{
  "id": "60da5aedd73e4ca683f0f3ae1450900d",
  "semantic_identifier": "Design--Enforce ownership checks on tag/priority updates and route non-owner edits to approval.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-06-15",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Enforce ownership checks on tag/priority updates and route non-owner edits to approval.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Design: Ownership enforcement + approval flow for tag/priority updates\n\nWe will add server-side enforcement so `tags` and `priority` can be mutated directly only by the current field owner (a specific user or team, as defined by existing ownership metadata). Any attempt to update these fields by a non-owner\u2014regardless of entry point (UI, public API, internal services, or integrations/webhooks)\u2014must not overwrite the canonical value. Instead, the backend will create a \u201cpending change request\u201d representing the proposed new value and return a structured response indicating the update requires approval.\n\nImplementation-wise, the write path for issue updates will route all tag/priority mutations through a single authorization gate (e.g., in the IssueUpdate service layer, not just the controller). The gate will (1) resolve field ownership for the issue and field, (2) compare it to the authenticated actor (user) and/or actor\u2019s team context, and (3) decide: apply immediately (owner) or enqueue request (non-owner). For non-owner edits, we\u2019ll persist a `ChangeRequest` record with: `issue_id`, `field` (`tags`/`priority`), `proposed_value` (normalized canonical representation), `requester_actor_id`, optional `requester_team_id`, `source` (ui/api/integration name), `source_request_id`/idempotency key, `status=pending`, and timestamps. We will enforce idempotency by de-duping pending requests for the same `(issue_id, field, proposed_value, requester)` within a short window or by request idempotency key, to prevent integration retries from spamming.\n\nAPI behavior will change to be explicit and non-breaking where possible: if a non-owner attempts to update, the response will return success for the overall request but include per-field results indicating `requires_approval: true`, the `pending_change_request_id`, and the current canonical value (so clients can reconcile). For strict clients, we can optionally also return HTTP `409 Conflict` or `403 Forbidden` behind a feature flag; default will be `200`/`202` with a structured payload to avoid breaking existing integrations that treat non-2xx as fatal. Owners updating will continue to behave as today and will also generate an audit entry for the applied change.\n\nFinally, we will ensure all entry points (UI mutations, REST/GraphQL, integrations) send consistent `source` metadata into the service layer so the change request and audit history capture where the request came from. We\u2019ll add audit log events for \u201cchange requested\u201d (non-owner) and \u201cchange applied\u201d (owner), including requester identity and proposed value. This design intentionally focuses only on backend enforcement and recording; a subsequent ticket can implement UI surfacing (e.g., approvals inbox, inline banner on the issue) using the persisted change request records.",
      "link": "https://www.onyx.app/42551"
    }
  ],
  "primary_owners": [
    "ryan_murphy"
  ],
  "secondary_owners": []
}