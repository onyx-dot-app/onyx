{
  "id": "c08c77294c0f4c8ca6f8975d6505fc2a",
  "semantic_identifier": "Design--Deduplicate and rate-limit warning_alerts notifications across email/Slack.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-19",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Deduplicate and rate-limit warning_alerts notifications across email/Slack.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Overview\nWe currently emit `warning_alerts` notifications on successive sync runs even when the underlying account/opportunity condition hasn\u2019t changed, resulting in duplicated emails and Slack messages. We will introduce a shared, cross-channel deduplication and rate-limiting layer keyed by the alert\u2019s identity and \u201cstate\u201d so that a given condition only notifies once until it either clears and re-triggers, or a configured cooldown interval elapses. This will make notifications idempotent across retries, repeated sync cycles, and multi-channel fan-out.\n\n### Idempotency key + persistence model\nFor each computed warning alert, we will derive an idempotency key from `{object_type, object_id, alert_type, threshold_state}` where `threshold_state` captures the semantic state of the condition (e.g., `below_threshold`, `above_threshold`, `missing_data`, etc.) rather than transient values. Before sending, we will upsert/check a persisted record (e.g., `warning_alert_notification_state`) containing `key`, `last_sent_at`, `last_seen_at`, `status` (`active`/`cleared`), and `cooldown_until`. If the key is currently `active` and `now < cooldown_until`, we skip all sends (email and Slack). If the alert is no longer present in a run, we mark the record `cleared` (or set `status=cleared` and update `last_seen_at`), allowing a future reappearance of the same condition to notify immediately as a re-trigger.\n\n### Cross-channel consistency + flow integration\nAll notification channels (email and Slack) will call the same gating function (e.g., `shouldSendWarningAlert(key, now)`) prior to rendering/sending. If the gate allows a send, we record the send once (single write) and then emit to both channels; if channel delivery is decoupled/async, we should record the send decision before enqueueing to prevent duplicate jobs from sending independently. Cooldown duration will be configurable per alert type (defaulting to a safe global value) to support noisier alerts without spamming. This design ensures \u201csend once per condition per object per state\u201d regardless of how many sync runs occur, while still allowing reminders after a defined interval if desired.\n\n### Tests and validation\nWe\u2019ll add a focused test suite covering: (1) duplicate sync runs with identical alerts result in a single notification across both email and Slack; (2) alert clears (no longer computed) and then re-triggers on a later run, resulting in a new notification; (3) cooldown behavior\u2014repeated runs within the cooldown do not send, and a run after the cooldown does; and (4) channel consistency\u2014if a send is suppressed, neither channel emits. We\u2019ll also include a small concurrency/idempotency test (or transactional assertion) to ensure two workers processing the same alert key cannot both pass the gate and send.",
      "link": "https://www.onyx.app/48238"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}