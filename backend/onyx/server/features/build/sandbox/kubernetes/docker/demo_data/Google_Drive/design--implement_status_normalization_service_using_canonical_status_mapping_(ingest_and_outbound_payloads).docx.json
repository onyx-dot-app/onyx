{
  "id": "f7b0ff3ef0cb45c581292f89d8024abc",
  "semantic_identifier": "Design--Implement status normalization service using canonical status mapping (ingest + outbound payloads).docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-12-28",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Implement status normalization service using canonical status mapping (ingest + outbound payloads).docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We will implement a shared status-normalization service that converts external system statuses (Zendesk/Intercom, Jira/Linear, CRM) into our canonical `Issue_Tracker` status enum using the mapping table defined in GOLD-197. The module will expose a small, consistent API (e.g., `normalize(sourceSystem, externalStatus) -> { canonicalStatus, externalStatus, mappingVersion, isFallback }`) and will be owned as a common library so both ingestion and outbound payload generation use the exact same logic and mapping data.\n\nIn ingestion and update pipelines, we will apply normalization at the boundary: whenever we parse or receive an issue payload from an external system, we store only the canonical status as the primary status field on the persisted issue object, while also retaining the original external status as metadata (e.g., `external.status`, `external.statusRaw`, `external.system`). This ensures internal consumers can rely on a stable status vocabulary, while still allowing support/debugging and future remapping without losing provenance. The mapping table will be versioned (or timestamped) so we can audit which mapping produced a given canonical status.\n\nFor unknown, deprecated, or unmapped external statuses, the module will assign an explicit fallback canonical status (e.g., `UNKNOWN`/`UNMAPPED` per the canonical enum) and mark the result as a fallback. Each fallback will emit a structured log event including source system, external status value, issue identifier, mapping version, and pipeline stage (ingest vs update vs outbound) so we can quantify and clean up gaps in mappings. This avoids hard failures while making the quality issue highly visible and actionable.\n\nFor outbound payloads, we will also use the normalization module to ensure any status field we emit is canonical (or consistently derived) and, where needed, include the original external status metadata for systems that require round-tripping. We will add unit tests covering all mapped statuses from GOLD-197, plus regression tests for fallback behavior and structured logging, and an integration test in each connector pipeline to verify that persisted issues always contain canonical status plus external status metadata and never an unnormalized status in the primary field.",
      "link": "https://www.onyx.app/11562"
    }
  ],
  "primary_owners": [
    "andre_robinson"
  ],
  "secondary_owners": []
}