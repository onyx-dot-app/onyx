{
  "id": "5af1aebd2491438f9dc66c3ac80c4c43",
  "semantic_identifier": "Design--Persist manual cluster merge/split decisions across re-ingest.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-25",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Persist manual cluster merge/split decisions across re-ingest.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Persist manual cluster merge/split decisions across re-ingest\n\nToday, manual merge/split actions in `issue_clustering` are applied to the current clustering output but can be lost when the same source conversations are re-ingested (e.g., replay/backfill), causing curated themes to revert, fragment, or reshuffle. This feature adds a durable \u201ccuration override\u201d layer that records user intent (merge groups and split rules) independently of any single clustering run, then deterministically reapplies those overrides after automated clustering but before downstream artifacts (cluster summaries/tags) are generated.\n\nWe will introduce a persisted override model keyed by stable source identity: a `curation_overrides` record scoped to `{workspace_id, dataset_id}` and referencing conversations by immutable `conversation_id` (or a canonical source key if that\u2019s what survives re-ingest). Overrides will include (1) **merge groups**: a set of conversation IDs that must end up in the same final cluster, and (2) **split rules**: a rule that forces specific conversations (or a predicate anchored to conversation IDs) to not co-reside in the same cluster. On ingestion, the pipeline produces `auto_clusters`; then an `apply_overrides(auto_clusters, overrides)` pass produces `final_clusters` by unioning merge groups via connected-components and enforcing split constraints by partitioning conflicting members into deterministic subclusters. The output is persisted with stable `cluster_id` derivation (e.g., hashing sorted conversation IDs plus workspace/dataset scope) so that re-ingests produce the same IDs and membership when inputs and overrides are unchanged.\n\nOperationally, curation mutations (merge/split) will write to this override store as the source of truth and also update the current materialized cluster view for immediate UI feedback. The ingestion/re-ingest path will read overrides, apply them, then generate summaries/tags strictly from `final_clusters` to ensure downstream consistency. We will also persist curation metadata on clusters (e.g., `has_manual_override`, `override_version`, and references to applied override records) so audit/debugging is possible and to prevent the UI from showing \u201cauto\u201d edits as user-curated.\n\nTesting will include a regression that: ingests a fixed set of conversations, performs a manual merge and a manual split, captures resulting `cluster_id`s, membership, and curation metadata, then replays ingestion of the same source conversations and asserts (a) cluster IDs are stable, (b) conversation-to-cluster membership is identical, and (c) curation metadata indicates the same overrides were applied. The test should also cover determinism (order-independent inputs) and the edge case where new conversations arrive alongside re-ingested ones (overrides still apply to the referenced conversations without breaking the rest of the clustering output).",
      "link": "https://www.onyx.app/79635"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}