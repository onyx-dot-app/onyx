{
  "id": "28fee96fcba4497aa1c135aa476b02d3",
  "semantic_identifier": "Design--Issue History: Hook lifecycle actions to emit status/priority/merge-split/link/note events.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-18",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Issue History: Hook lifecycle actions to emit status/priority/merge-split/link/note events.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We\u2019ll add a service-layer \u201cIssueHistory\u201d event emitter that standardizes how backend mutations record timeline events. The emitter will expose helpers for the MVP event types: `STATUS_CHANGED`, `PRIORITY_CHANGED`, `ISSUES_MERGED`, `ISSUE_SPLIT`, `ISSUE_LINKED` (for external work items), and `NOTE_ADDED`. Each helper will accept the acting user (actor), the issue context, and a typed payload, and will write an immutable `issue_history_events` record with `issue_id`, `event_type`, `actor_id`, `created_at` (server time), and `payload` (JSON) suitable for future timeline rendering.\n\nWe\u2019ll define payload schemas per event to ensure we capture \u201cfrom/to\u201d state transitions and relationship identifiers. For status/priority we\u2019ll store `{from, to}` values (using stable IDs or enums, plus optional display names). For merge/split we\u2019ll store `{source_issue_id, target_issue_id}` (and optionally arrays for multi-merge), and for external links we\u2019ll store `{external_system, external_id?, url, action}` with `action` indicating add/remove if applicable. For notes we\u2019ll store `{note_id, body_excerpt?, full_body?}`; if we don\u2019t want to duplicate content, we\u2019ll store only `note_id` plus an excerpt to support quick timeline display later.\n\nNext we\u2019ll \u201chook lifecycle actions\u201d by wiring these helpers into existing Issue mutation flows at the service boundary (not GraphQL/controller), so any change path produces consistent events. Concretely: status and priority setters emit after a successful update when the value actually changes; merge/split emit once per completed operation; note creation emits after the note is persisted; external link add/remove emits after link persistence. Emission will run in the same DB transaction as the mutation to guarantee atomicity (no history without the change, and no change without history).\n\nTo keep behavior consistent and testable, we\u2019ll centralize diffing/guardrails: no-op updates produce no events; actor is required (system actions use a designated system actor); timestamps use server time; payload validation is enforced at the helper boundary. We\u2019ll add integration tests per mutation verifying one event is recorded with correct `actor_id`, `event_type`, and payload fields, plus regression tests for edge cases (repeated updates, failed transactions, bulk merges) to ensure event emission is reliable without adding any UI.",
      "link": "https://www.onyx.app/83625"
    }
  ],
  "primary_owners": [
    "ryan_murphy"
  ],
  "secondary_owners": []
}