{
  "id": "dce5dc22db6942e785e4bcc659e8435f",
  "semantic_identifier": "Design--Expose recommendation conflict metadata via API for segment positioning views.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-07-13",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Expose recommendation conflict metadata via API for segment positioning views.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Summary / Goal  \nWe will extend the Positioning Recommendations API to optionally return persisted recommendation conflict metadata (stored by the GOLD-32 pipeline) alongside recommendations for one or more segments. This enables the segment positioning views UI to surface \u201cwhy\u201d a recommendation is conflicted, including which other segments it conflicts with and the exact statements that are incompatible. The feature must enforce workspace isolation (no cross-workspace conflict leakage) and provide a stable, versionable response schema suitable for long-lived UI consumption.\n\n### API Surface & Response Schema  \nWe\u2019ll add an opt-in include flag to the existing recommendations fetch (preferred to avoid breaking changes), e.g. `GET /v1/positioning/recommendations?segment_ids=...&include=conflicts` (or equivalent RPC). Response will include `recommendations[]` as today plus a `conflicts[]` collection keyed by `recommendation_id` (and/or `segment_id`) to support multiple conflicts per recommendation. Each conflict object will contain: `conflict_id`, `segment_id` (the segment being viewed), `conflicting_segment_ids[]` (or `conflicting_segments[]` with id + display name if already available), `category`/`field` (the recommendation dimension that conflicts, e.g. \u201cValue Prop\u201d / \u201cDifferentiator\u201d), and `statements[]` capturing the conflicting statements with minimal stable structure (e.g. `{ segment_id, text, source, statement_id? }`). Schema will be explicitly additive and versioned via standard API versioning to keep it stable for the UI.\n\n### Querying, Pagination, and Filtering  \nConflicts may be numerous, so we\u2019ll support pagination on the conflicts collection (cursor-based) and basic filters aligned to the UI: by `segment_id`, by `category/field`, and optionally by `recommendation_id`. When fetching multiple segments, conflicts will be returned only for the requested segments and tied back via IDs to avoid duplicative payloads. If the UI needs \u201ctop N conflicts per segment,\u201d we can add a `conflicts_limit_per_segment` parameter; otherwise, default limits + pagination will be applied.\n\n### Data Access, Security, and Testing  \nThe API will read conflict metadata from the persisted store produced by GOLD-32 (DB table(s) or document store), joining on recommendation/segment identifiers already used by the recommendations API. Every query will be scoped by `workspace_id` from auth context, ensuring we only return conflicts belonging to the requesting workspace; conflicting segment references will be validated to the same workspace. We\u2019ll add integration tests that seed two workspaces with overlapping segment IDs (or similar identifiers) to assert strict isolation, and tests covering: include flag behavior, multi-segment requests, pagination correctness, and schema stability (presence/shape of fields).",
      "link": "https://www.onyx.app/57762"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}