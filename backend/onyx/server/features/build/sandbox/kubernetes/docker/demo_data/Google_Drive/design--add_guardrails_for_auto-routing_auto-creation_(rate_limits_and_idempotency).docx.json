{
  "id": "54b507c8a56241fc9df12ddff657e6dd",
  "semantic_identifier": "Design--Add guardrails for auto-routing/auto-creation (rate limits + idempotency).docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-10-20",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add guardrails for auto-routing/auto-creation (rate limits + idempotency).docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We should add backend guardrails around Issue_Tracker\u2019s auto-routing and auto-creation flows to prevent Jira spam and ownership thrash. The two primary protections are (1) per-workspace rate limiting for outbound Jira creates and auto-routing actions, and (2) strict idempotency for \u201cissue \u2192 Jira ticket creation\u201d so that retries, webhook replays, and dedupe/cluster updates cannot generate duplicates. The goal is to make these workflows safe under at-least-once delivery and repeated event processing, while preserving legitimate creates/reroutes.\n\nFor rate limiting, introduce a workspace-scoped limiter (e.g., token bucket) with separate quotas for \u201ccreate Jira issue\u201d and \u201capply auto-route,\u201d enforced at the service boundary right before calling Jira or mutating ownership. When the limiter blocks, we should skip the action (do not enqueue further retries blindly), emit a structured audit log, and optionally schedule a deferred retry via a controlled queue with jitter/backoff if the operation is still relevant. Limits should be configurable (defaults + per-workspace overrides) and measured with counters for allowed/blocked to support tuning.\n\nFor idempotency, require a deterministic idempotency key for every Jira create derived from stable identifiers (e.g., workspace_id + Issue_Tracker issue_id + integration_id + \u201ccreate\u201d operation + creation variant). Persist an \u201cidempotency record\u201d that maps key \u2192 created Jira issue key/ID (or \u201cin-flight/failed\u201d with timestamps) and enforce uniqueness at the database level so concurrent workers cannot create duplicates. On duplicate attempts, return the previously created Jira issue reference without calling Jira. For rerouting, apply a similar \u201cdedupe key\u201d per (issue_id, target_owner, rule_version) so repeated events don\u2019t repeatedly re-apply the same ownership change; treat reroute as idempotent by checking current state before writing.\n\nFinally, we should log and surface blocked/deduped attempts with explicit reason codes (RATE_LIMITED_CREATE, RATE_LIMITED_ROUTE, IDEMPOTENT_REPLAY, DUPLICATE_IN_FLIGHT, NOOP_ALREADY_ROUTED, etc.) including workspace, issue, integration, and correlation IDs. These events should be queryable (admin/audit view and dashboards) to support debugging, compliance/auditing, and iterative limit tuning. We\u2019ll validate with load tests and replay scenarios (retries, webhook replays, concurrent workers, cluster/dedupe updates) to ensure exactly-one Jira create per source issue and stable routing behavior under churn.",
      "link": "https://www.onyx.app/88001"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}