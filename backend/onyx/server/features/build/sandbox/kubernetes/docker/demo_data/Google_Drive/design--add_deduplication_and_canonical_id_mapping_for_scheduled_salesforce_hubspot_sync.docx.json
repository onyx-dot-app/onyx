{
  "id": "8121896609a448ecae4077098c04b5b1",
  "semantic_identifier": "Design--Add deduplication + canonical ID mapping for scheduled Salesforce/HubSpot sync.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-05-28",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add deduplication + canonical ID mapping for scheduled Salesforce/HubSpot sync.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We will add a deduplication and canonical-ID mapping layer on top of the existing scheduled read-only Salesforce/HubSpot refresh (GOLD-80) so repeated sync runs converge to a single stable internal entity per CRM object (accounts, contacts, opportunities). The core abstraction is a **CanonicalRecord** table keyed by `(workspace_id, crm_provider, crm_object_type, crm_record_id)` that maps to a single internal entity ID, plus a lightweight **alias/history** list to preserve prior CRM IDs when records are merged, deleted, or re-keyed. All downstream consumers (notably Sales_Accelerator forecasting and next-best-action) will reference the canonical internal ID, ensuring consistent entity identity over time.\n\nDuring each scheduled run, after pulling CRM records we will run a deterministic dedupe pass per workspace and object type. First we resolve each incoming record via the canonical mapping; if no mapping exists we create one provisionally. Then we detect duplicates using a provider-specific set of match keys (e.g., exact CRM record ID match, then configured secondary keys such as normalized email for contacts or normalized domain/account name for accounts, and opportunity external ID/name+account constraints) and apply **merge rules** for in-scope fields: prefer non-null over null, prefer \u201cmost recently updated in CRM\u201d when conflicting, and maintain field-level provenance for auditability. If two internal entities are found to represent the same real-world record, we merge to one canonical internal entity, update all mappings to point to it, and emit a stable redirect/alias so historical references remain valid.\n\nWe will handle deletes and CRM ID changes safely by modeling mapping state and tombstones. If the CRM indicates deletion (or the record disappears under a \u201chard delete detectable\u201d mode), we mark the canonical mapping as deleted while keeping the internal entity for referential integrity and historical reporting; downstream logic can filter by active/deleted as needed. If a record\u2019s CRM ID changes (common in some HubSpot reimports or Salesforce merges), we create a new mapping entry for the new ID, link it to the same canonical internal entity, and retain the old ID in the alias/history set, preventing accidental duplication on the next run.\n\nFinally, each run will produce structured logs and metrics so we can verify dedupe effectiveness and catch regressions: counts of records processed per object, new mappings created, duplicates detected, merges performed, conflicts encountered (by field), and deleted/tombstoned mappings. We will attach a `sync_run_id` to all outcomes and publish dashboards/alerts on abnormal merge/conflict rates. This gives Sales_Accelerator a single stable internal entity per CRM record and provides observability to ensure scheduled sync runs remain idempotent and safe.",
      "link": "https://www.onyx.app/48912"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}