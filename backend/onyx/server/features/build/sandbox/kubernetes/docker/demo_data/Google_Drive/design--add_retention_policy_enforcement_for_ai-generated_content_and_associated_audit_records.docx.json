{
  "id": "b9f325a30758495499fb6f287c8dbea1",
  "semantic_identifier": "Design--Add retention policy enforcement for AI-generated content and associated audit records.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-11-16",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add retention policy enforcement for AI-generated content and associated audit records.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We will add backend retention policy enforcement for AI-generated artifacts (e.g., generated emails, call notes, next-best-action recommendations) and their associated audit records, configurable per tenant. Policies will specify a retention period (in days) and a disposition mode (hard-delete vs anonymize) for each artifact type, with sensible defaults and the ability to override at the tenant level. Retention will be enforced independent of UI behavior to ensure expired content cannot be accessed through any API route, background job, or internal tool.\n\nData model changes will introduce a per-tenant `retention_policy` configuration plus per-record metadata on AI artifacts/audit records (e.g., `created_at`, `expires_at`, `retention_mode_applied_at`, and optionally `anonymized_at` / `deleted_at` if we use soft markers during processing). We\u2019ll preserve referential integrity by designing deletion/anonymization strategies per table: for hard-delete, cascade only where safe and otherwise replace with tombstone rows or null out optional foreign keys; for anonymization, retain row identity and relational links while scrubbing payload fields (text bodies, model inputs/outputs, prompts, and any PII-bearing fields) and replacing them with a standardized \u201cexpired per retention policy\u201d marker.\n\nEnforcement will be implemented via a scheduled cleanup job (e.g., daily) that scans for records past `expires_at` and applies the configured disposition in batches with idempotency (safe retries) and metrics (counts processed, failures, lag). In parallel, read paths will add a lightweight \u201cretention gate\u201d that filters expired content even before cleanup runs (e.g., `WHERE expires_at IS NULL OR expires_at > now()`), ensuring immediate policy compliance and preventing leakage. Cleanup will also handle audit records by either deleting them alongside the artifact or anonymizing their payload while keeping non-sensitive event metadata required for system integrity.\n\nFor admin validation, we will expose retention metadata on relevant admin-facing APIs (and optionally UI surfaces) without duplicating RBAC or audit capture work: `expires_at`, `retention_policy_id/version`, and current `retention_state` (active/expired/purged/anonymized). Admins can query a record to confirm when it will expire and what action will occur, and can list recently purged/anonymized counts at the tenant level for troubleshooting. Access to this metadata will reuse existing admin authorization checks, and non-admin endpoints will simply behave as if expired content does not exist (404 / empty results) to avoid hinting at previously existing data.",
      "link": "https://www.onyx.app/72502"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}