{
  "id": "47505bb5e42d4b8195724849d1c520a9",
  "semantic_identifier": "Design--Issue History: Add read API for issue_history timeline (ordered, paginated, permissioned).docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-04-28",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Issue History: Add read API for issue_history timeline (ordered, paginated, permissioned).docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Overview\nWe will add a read API and supporting service layer to fetch an Issue\u2019s `issue_history` as a timeline suitable for UI rendering. The API will return events in a stable chronological order (oldest\u2192newest by default, with an option to reverse) and support cursor-based pagination so the client can efficiently load more history as the user scrolls. The response will normalize actor metadata across all event types and enforce minimal, consistent payload shapes per event type to keep the UI predictable and reduce coupling to internal schemas.\n\n### API & Data Contract\nIntroduce `GET /issues/{issueId}/history` (or GraphQL equivalent) returning `{ data: IssueHistoryEvent[], pageInfo }`. Each `IssueHistoryEvent` includes common fields: `id`, `type`, `createdAt`, `actor` (normalized: `id`, `displayName`, `avatarUrl`, `kind`), and `redacted` (boolean) when applicable. Per-type payloads will be small and consistent, e.g.:\n- `status_changed`: `{ fromStatusId, toStatusId }`\n- `priority_changed`: `{ fromPriority, toPriority }`\n- `merge_split`: `{ action, relatedIssueId }`\n- `note`: `{ noteId, preview }` (no full body unless already authorized elsewhere)\n- `external_link`: `{ url, title }`\nPagination will use opaque cursors derived from `(createdAt, id)` to guarantee stable ordering when timestamps collide. Support `first/after` (and optionally `last/before`) with deterministic sorting to avoid duplicates/missing items across pages.\n\n### Permissions & Redaction\nAccess control will mirror Issue visibility: callers must be authorized to read the Issue to read its history. Additionally, events that reference objects with stricter permissions (e.g., notes or related issues) will be redacted rather than omitted to preserve timeline continuity (e.g., keep timestamp/type but replace sensitive fields and set `redacted: true`). Actor metadata will be normalized and also subject to redaction (e.g., deleted users, external actors) using a consistent \u201csystem\u201d or \u201cunknown\u201d representation.\n\n### Implementation & Tests\nImplement a service method (e.g., `IssueHistoryService.list(issueId, pagination, viewer)`) that queries `issue_history` with a composite stable sort, applies permission filters/redaction, and maps DB rows into the unified event schema. Add basic tests covering: (1) stable chronological ordering with tie-breakers, (2) cursor pagination correctness (no gaps/duplicates across pages), and (3) permission behavior (no access without Issue read permission; redaction of restricted sub-resources while keeping event envelope). Include contract-level snapshot tests for a few representative event types to ensure payload shapes remain minimal and consistent.",
      "link": "https://www.onyx.app/63596"
    }
  ],
  "primary_owners": [
    "tyler_jenkins"
  ],
  "secondary_owners": []
}