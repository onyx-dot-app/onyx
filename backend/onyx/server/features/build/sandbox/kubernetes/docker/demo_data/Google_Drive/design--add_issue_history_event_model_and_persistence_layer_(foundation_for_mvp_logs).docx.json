{
  "id": "bd81d632e0c84d9aa632277b4ed5d79a",
  "semantic_identifier": "Design--Add issue_history event model + persistence layer (foundation for MVP logs).docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-05-02",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add issue_history event model + persistence layer (foundation for MVP logs).docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Overview\nWe will introduce an `issue_history` append-only event log as the canonical persistence layer for tracking all significant changes and annotations tied to a standardized `Issue`. This log is the foundation for MVP \u201clogs\u201d and will be written by backend services whenever issue state changes (or when a user/system adds a note or external link). This ticket explicitly does not cover UI rendering; it focuses on schema, domain model, and basic write pathways.\n\n### Data model + schema\nCreate a new `issue_history` table keyed by an immutable event id (UUID/ULID) and partitioned/indexed for efficient reads by `issue_id` and time (e.g., `(issue_id, occurred_at desc)`). Core columns: `id`, `issue_id` (FK), `event_type` (string/enum), `payload` (JSONB), `actor_type` (user/service/system), `actor_id` (nullable), `occurred_at` (event time), `created_at` (ingest time), and optional `correlation_id`/`request_id` for tracing. The payload is JSONB to avoid migrations per new event while still enforcing minimal validation at the domain layer. Consider optional fields like `source` (api/automation/import) and `visibility` (internal/public) if needed by downstream consumers.\n\n### Event types + payload conventions\nDefine an initial set of event types to cover upcoming needs: `status_changed`, `priority_changed`, `issue_merged`, `issue_split`, `note_added`, and `external_link_added` (and optionally `external_link_removed`). Each payload should follow a consistent structure: `{\"from\": ..., \"to\": ...}` for transitions, and typed objects for entities (e.g., `{\"target_issue_id\": \"...\", \"strategy\": \"merge\"}`; `{\"note_id\": \"...\", \"body\": \"...\", \"format\": \"markdown\"}`; `{\"url\": \"...\", \"title\": \"...\", \"provider\": \"...\"}\"`). The domain model should validate required keys per `event_type`, but remain forward-compatible by allowing additional keys. We should document the contract and add unit tests to lock in payload shape per event.\n\n### Write APIs / service helpers\nImplement a small `IssueHistoryService` (or repository + service) with a single append method, e.g. `appendEvent(issueId, eventType, payload, actor, occurredAt=now, correlationId?)`, used by other domain services when they mutate issues or accept user actions. Writes must be strictly insert-only (no updates/deletes) and should be part of the same transaction as the state change when applicable, ensuring the history reflects persisted state. Provide lightweight helpers for common events (e.g., `recordStatusChange(...)`) to reduce call-site duplication, and add integration tests to ensure events are recorded with correct actor, timestamps, and ordering guarantees (by `occurred_at`, then `id` as tie-breaker).",
      "link": "https://www.onyx.app/96693"
    }
  ],
  "primary_owners": [
    "jason_morris"
  ],
  "secondary_owners": []
}