{
  "id": "22684c83432a475f8c8223b27d1a733a",
  "semantic_identifier": "Design--Follow-up workflow: Mutual Action Plan templates not loading/applying correctly.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-08-22",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Follow-up workflow: Mutual Action Plan templates not loading/applying correctly.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Overview / Problem\nMutual Action Plan (MAP) template selection is currently unreliable: the template list sometimes fails to load for the selected account/opportunity, and applying a template can drop steps, duplicate steps, or fall back to empty/default steps. This is most visible after CRM sync or opportunity stage changes, where the UI and backend disagree on the \u201ccurrent\u201d opportunity context and template eligibility. The goal is to make template fetch + apply deterministic for a given MAP creation/edit session, and to verify correctness with lightweight production instrumentation.\n\n### Proposed Design\nWe will treat \u201ctemplate resolution\u201d as a pure function of a stable context object: `{accountId, opportunityId, opportunityStage, crmSource, templateVersion}` captured at MAP creation (or when opening the template picker) and persisted on the MAP as `templateContext`. The template list API will require `accountId` and `opportunityId` (or a server-resolved default opportunity for the account) and will return templates filtered by the resolved opportunity stage at the time of request, plus a `contextHash` that the client must echo when applying a template. Applying a template will become an idempotent server-side operation: `POST /maps/{mapId}/apply-template {templateId, contextHash, mode}` where `mode=replace` replaces all steps with the template\u2019s canonical ordered steps; the server will compute a deterministic step set (stable step IDs derived from template step IDs + mapId) to prevent duplicates on retries and will reject apply if the `contextHash` no longer matches (prompting the client to refresh templates).\n\n### Edge Cases / Consistency Guarantees\nOn CRM sync or opportunity stage change, we will not silently \u201creinterpret\u201d an in-progress template selection. If the opportunity context changes mid-flow, the next template list fetch will return a new `contextHash`; any attempt to apply a template chosen under the old context will fail with a specific error (`409 TEMPLATE_CONTEXT_STALE`), and the UI will prompt the user to reselect. MAP creation will be two-phase: create MAP with captured `templateContext`, then apply template; if apply fails, we leave the MAP in a known empty state with an explicit \u201cno template applied\u201d flag rather than default steps. We will also enforce server-side dedupe (by stable step IDs and ordering) and transactional writes so partial applies cannot result in mixed/duplicated step sets.\n\n### Instrumentation / Validation\nAdd lightweight structured logging and counters for: `map_template_list_fetch` (inputs: accountId/opportunityId/stage, outputs: templateCount, latency, contextHash), `map_template_apply` (templateId, mapId, contextHash match/mismatch, stepCountBefore/After, dedupeCount, retries), and `map_created` (createdWithTemplate, applySuccess, failureReason). Include correlation IDs from client session through MAP creation and apply calls to trace end-to-end. Success criteria: near-zero `TEMPLATE_CONTEXT_STALE` after UI refresh behavior, elimination of MAPs created with empty/default steps when a template was selected, and no observed step duplication/drop in apply metrics (stepCountAfter equals template canonical count, dedupeCount ~0 except retries).",
      "link": "https://www.onyx.app/59658"
    }
  ],
  "primary_owners": [
    "jiwon_kang"
  ],
  "secondary_owners": []
}