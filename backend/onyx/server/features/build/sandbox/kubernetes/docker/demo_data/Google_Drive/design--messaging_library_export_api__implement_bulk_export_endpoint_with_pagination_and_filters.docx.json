{
  "id": "47a7e8dae9754f0c8b366d8e90853b87",
  "semantic_identifier": "Design--Messaging Library Export API: implement bulk export endpoint with pagination + filters.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2026-01-17",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Messaging Library Export API: implement bulk export endpoint with pagination + filters.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "This feature adds a bulk export API for the Messaging Library that returns only *approved* assets for a given workspace, enabling downstream clients to sync content efficiently. The primary endpoint will be scoped by `workspace_id` and will return a paginated list of assets plus enough metadata to support incremental synchronization and resumability. Approval-state/versioning rules are treated as an upstream invariant (handled in GOLD-44); this work focuses on endpoint behavior, data shape, stable ordering, and query performance.\n\n**API shape/behavior.** Provide `GET /workspaces/{workspace_id}/messaging-library/assets:export` (or equivalent) with query params: `limit` (bounded, e.g. 1\u2013500), `cursor` (opaque), and optional filters: `asset_type`, `segment`/`icp` (allow multiple values if supported), and `updated_since` (timestamp). Response includes `items: [...]`, `next_cursor` (null when exhausted), and `total_count` when feasible without degrading performance (otherwise omit or return `null`). Each item should include: `id`, `type`, `title/name`, `content` (or a reference/URL if content is large), `segment/icp`, `updated_at`, `created_at`, and any client-relevant version identifier (e.g., `approved_version_id`) to support deterministic reconciliation.\n\n**Pagination + stable ordering.** To ensure stable, gap-free pagination under concurrent updates, order by `(updated_at ASC, id ASC)` and encode the cursor as the last seen tuple `{updated_at, id}` (opaque base64/JSON). Filtering applies before pagination. `updated_since` should be inclusive/exclusive in a documented way (prefer `>` and rely on the `(updated_at,id)` cursor for full correctness). This ordering also supports incremental sync: clients can store the last cursor (or last `(updated_at,id)`) and resume without re-downloading the full dataset.\n\n**Performance considerations.** Queries must be index-backed: composite index on `(workspace_id, approval_state, updated_at, id)` and additional selective indexes for `asset_type` and `segment/icp` (either separate indexes or expanded composite depending on cardinality). Ensure all filters are sargable and avoid `OFFSET` pagination. `total_count` should be computed only when cheap (e.g., cached, approximate, or behind an opt-in flag) to avoid full scans on large workspaces. Add basic guardrails (max `limit`, request timeouts) and instrumentation (latency, rows returned, cursor usage) to validate performance in production.",
      "link": "https://www.onyx.app/40243"
    }
  ],
  "primary_owners": [
    "kevin_sullivan"
  ],
  "secondary_owners": []
}