{
  "id": "8ec0767570984becbc932cea644951c2",
  "semantic_identifier": "Design--Instrument recommendation lifecycle events in Sales_Accelerator (shown/accepted/executed).docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-11-18",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Instrument recommendation lifecycle events in Sales_Accelerator (shown/accepted/executed).docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "This feature adds closed-loop telemetry for the Sales_Accelerator recommendation lifecycle by emitting three canonical events\u2014`recommendation_shown`, `recommendation_accepted` (aka applied), and `recommendation_executed`\u2014using the event schema defined in GOLD-106. The goal is to measure end-to-end recommendation effectiveness and adoption by linking UI exposure through rep action to downstream execution, without impacting core Sales_Accelerator workflows.\n\nOn the client, we will instrument the UI surfaces where recommendations are rendered and interacted with. A `recommendation_shown` event fires when a recommendation card enters the viewport (with debouncing to avoid duplicate emits on re-render), and a `recommendation_accepted` event fires when the rep clicks \u201cApply/Accept\u201d and the client initiates the corresponding action (e.g., create task, enroll in sequence, update field). Each event will include a stable `recommendation_instance_id` generated at the time the recommendation is materialized for the rep (returned from the server alongside the recommendation payload), plus required context: segment identifiers, rep/user identifiers, motion type, target entity (account/opportunity) identifiers, CRM IDs, and an event timestamp.\n\nOn the server, we will instrument the execution path(s) that represent completion of the recommendation\u2019s intended outcome, emitting `recommendation_executed` once the associated operation succeeds (e.g., sequence enrollment created, activity logged, CRM write confirmed). The server will accept client-originated shown/accepted events via an internal ingestion endpoint (or existing telemetry pipe), validate against the GOLD-106 schema, enrich with authoritative server context where available (e.g., canonical CRM IDs, org/workspace), and forward to the telemetry sink. `recommendation_instance_id` is the join key across all three events; if the server re-derives or retries operations, we must maintain idempotency by ensuring the same instance id is reused and adding an optional dedupe key (e.g., instance id + event type).\n\nTo avoid blocking user workflows, event emission will be best-effort with batching and retry. The client will queue events in memory (and optionally local storage for short-lived resilience), flush on a timer and on page hide, and retry with exponential backoff on transient failures; hard validation failures will be dropped with structured logs (including schema error details and sampling) so we can detect regressions. The server will log invalid payloads, missing required context, and downstream delivery failures, and expose basic metrics (accepted/dropped/failed counts by event type) to ensure we can monitor data quality without impacting recommendation rendering or execution paths.",
      "link": "https://www.onyx.app/31751"
    }
  ],
  "primary_owners": [
    "brooke_spencer"
  ],
  "secondary_owners": []
}