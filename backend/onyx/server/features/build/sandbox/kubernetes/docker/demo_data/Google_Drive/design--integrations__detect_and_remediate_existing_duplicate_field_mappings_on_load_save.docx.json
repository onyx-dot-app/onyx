{
  "id": "5048143825734010a4b8f2f207f3c4e4",
  "semantic_identifier": "Design--Integrations: Detect and remediate existing duplicate field mappings on load/save.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-07-31",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Integrations: Detect and remediate existing duplicate field mappings on load/save.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Summary / Problem\nSome existing integration configurations contain duplicate or conflicting field mappings (e.g., multiple source fields mapping to the same destination, or the same source mapped multiple times). These legacy configs can produce duplicate downstream signals and can slow or fail sync runs. We need backend-side detection at read/write time, plus a one-time remediation mechanism to prevent known-bad configs from continuing to degrade performance.\n\n### Detection on Load and Save\nWe will add validation logic in the integration-config service on both **fetch (GET/load)** and **persist (PUT/PATCH/save)** paths. The validator will normalize mappings (canonical field identifiers, case/whitespace normalization where applicable) and detect: (1) exact duplicates, (2) conflicting source\u2192destination pairs, and (3) many-to-one or one-to-many collisions where the destination (or source) must be unique for the given integration type. On load, the API will return the config plus a `mapping_issues` payload (warnings for safe-to-auto-fix, errors for user-required resolution). On save, if errors exist, the API will reject with 4xx and the same structured payload; warnings may be accepted but returned so the UI can prompt remediation.\n\n### Structured Issue Payload (Contract)\nIntroduce a stable, typed response shape, e.g.:\n- `mapping_issues: { status: \"ok\"|\"warning\"|\"error\", issues: Issue[] }`\n- `Issue: { code, severity, message, mappings: [{source_field_id, destination_field_id, mapping_id?}], remediation: {type: \"auto\"|\"manual\", action?: \"dedup\"|\"choose_one\"|\"rename_destination\"|...} }`\nThis payload is designed to be UI-friendly (highlight exact rows) and machine-actionable for remediation endpoints. We will also log metrics (count of configs with issues, issue types) to track rollout and impact on sync reliability.\n\n### One-time Remediation Path\nAdd a remediation flow that can be invoked on load or explicitly via an endpoint (e.g. `POST /integrations/{id}/configs/{configId}/remediate-mappings`). The backend will **auto-deduplicate when safe** (exact duplicates where removing extras is semantics-preserving; preference order: newest mapping wins or stable deterministic rule) and return the updated config plus a record of changes applied. If conflicts require human choice (e.g. two different sources mapped to a destination that must be unique), the remediation response will indicate `manual` issues and the save path will remain blocked until resolved. To keep this \u201cone-time,\u201d we\u2019ll store a `remediation_version`/flag on the config so we don\u2019t repeatedly mutate configs, while still continuing to validate on every load/save to prevent regressions.",
      "link": "https://www.onyx.app/73699"
    }
  ],
  "primary_owners": [
    "brooke_spencer"
  ],
  "secondary_owners": []
}