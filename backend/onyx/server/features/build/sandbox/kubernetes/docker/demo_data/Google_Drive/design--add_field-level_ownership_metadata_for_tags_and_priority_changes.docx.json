{
  "id": "ff60d110dbd44998837e434f9633585c",
  "semantic_identifier": "Design--Add field-level ownership metadata for tags and priority changes.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-09-16",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Add field-level ownership metadata for tags and priority changes.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "We will add backend support to persist and expose field-level ownership and attribution metadata specifically for issue **tags** and **priority**. For each of these fields we will store (a) the current \u201cowner\u201d (a `Team` or `User` reference), and (b) the most recent edit attribution: `lastEditedBy` (actor identity), `lastEditedAt` (timestamp), and `lastEditSource` (UI/API/integration). This is explicitly additive metadata only: it will not change current edit permissions, workflows, or issue update behavior; it will only enable future enforcement/approval features to reason about \u201cwho owns this field\u201d and \u201cwho last changed it.\u201d\n\nOn write paths, any update that changes tags and/or priority will populate an audit payload derived from the authenticated actor (user/service account), the request context (UI/API/integration), and server time. We will implement this in the central issue update service so all entry points (web UI, public API, internal tools, integrations) converge on the same logic, and we will only write metadata when the corresponding field actually changes. Ownership assignment will initially be derived from existing context (e.g., default to the issue\u2019s team on creation, and keep existing owner unless explicitly reassigned), with an explicit backend API to set/clear owner for tags/priority so future approval flows can manage it without schema churn.\n\nOn the data model side, we will introduce a small, field-scoped metadata structure per issue (e.g., `tagsMetadata` and `priorityMetadata`) containing `ownerType`/`ownerId`, plus `lastEditedById`, `lastEditedAt`, and `lastEditSource`. This can be stored as dedicated columns/foreign keys or as a JSONB blob depending on existing patterns, but it must support efficient reads for lists and issue detail views. We will backfill existing issues with `owner = issue.team` and null/unknown last-edit attribution (or best-effort from existing audit logs if available), ensuring the migration is safe and online.\n\nWe will expose these fields through the backend (GraphQL/REST) on issue reads, and accept them only via internal/admin mutation endpoints for now (or behind a feature flag), since the ticket goal is attribution and audit rather than behavior change. We will add unit/integration tests covering: UI/API/integration sources, mixed updates (e.g., title + priority), no-op updates, and permission edge cases where the actor is a bot/service. Finally, we will instrument writes (e.g., counter for \u201ctags/priority change with attribution recorded\u201d) to validate adoption and ensure future tickets can reliably enforce ownership and approval flows on top of this metadata.",
      "link": "https://www.onyx.app/77781"
    }
  ],
  "primary_owners": [
    "jiwon_kang"
  ],
  "secondary_owners": []
}