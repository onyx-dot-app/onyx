{
  "id": "5c7164f736734d4db5de72699092ca28",
  "semantic_identifier": "Design--Follow-up workflow: Ensure multi-threading prompts refresh and de-duplicate after CRM/contact changes.docx",
  "title": null,
  "source": "google_doc",
  "doc_updated_at": "2025-07-19",
  "metadata": {
    "owner_names": ""
  },
  "doc_metadata": {
    "hierarchy": {
      "source_path": [
        "My Drive"
      ],
      "drive_id": null,
      "file_name": "Design--Follow-up workflow: Ensure multi-threading prompts refresh and de-duplicate after CRM/contact changes.docx",
      "mime_type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }
  },
  "sections": [
    {
      "text": "### Background / Problem\nOur follow-up workflow supports \u201cmulti-threading\u201d prompts (multiple suggested follow-ups per account/opportunity). Today, prompt eligibility and rendering are partially cached, so when underlying entities change\u2014contact updates from CRM sync, contact merges, role/persona updates, or opportunity stage transitions\u2014the UI can show stale prompts, drop prompts unexpectedly, or render duplicates. The root issue is that the prompt service/UI does not consistently treat these changes as invalidating events, and we don\u2019t have sufficient production visibility into when prompts were recomputed vs. reused.\n\n### Goals / Non-goals\n**Goals:** (1) Ensure multi-threading prompts recompute on relevant data changes and re-render deterministically, (2) eliminate duplicates via stable prompt identity and client/server de-duplication, and (3) add lightweight instrumentation to confirm refresh triggers and rendered prompt IDs in production. **Non-goals:** redesigning the prompt ranking model, changing prompt copy, or building a comprehensive analytics pipeline\u2014this is correctness and observability, not product iteration.\n\n### Proposed Design\nIntroduce a single \u201cprompt invalidation + refresh\u201d contract driven by entity-versioning and explicit triggers. On the backend, attach a `data_fingerprint` (or `eligibility_version`) to prompt results keyed by `{account_id, opportunity_id}` derived from: opportunity stage, contact IDs participating, and each contact\u2019s relevant fields (role/persona + merge lineage). When any of these inputs change, the fingerprint changes and cached eligibility is bypassed/recomputed; cache entries should also be invalidated on merge events (old contact IDs \u2192 canonical ID). Each prompt result must include a stable `prompt_id` (hash of prompt type + target entity IDs + opportunity stage) so the UI can safely de-duplicate and treat updates as replacements rather than additive appends.\n\n### UI Behavior + Instrumentation\nOn the frontend, always render prompts from the latest response snapshot and de-duplicate by `prompt_id` before display. Trigger a refresh on: (a) opportunity stage change events, (b) contact record update/merge events affecting the account/opportunity, and (c) explicit \u201cCRM sync completed\u201d events; if eventing is not available in some surfaces, add a bounded polling fallback (e.g., refresh on view focus + short TTL). Add minimal logs/metrics: `prompt_refresh_triggered` with `{trigger_type, account_id, opportunity_id, previous_fingerprint, new_fingerprint}` and `prompts_rendered` with `{account_id, opportunity_id, fingerprint, prompt_ids[] (sampled)}`. This gives us a production audit trail to confirm recomputation on change, and to detect any remaining stale/duplicate rendering.",
      "link": "https://www.onyx.app/56577"
    }
  ],
  "primary_owners": [
    "ryan_murphy"
  ],
  "secondary_owners": []
}